#
# run a prg file for single-time used testcases
#
proc single-run { src } {

  set path [split $src "/"]
  set filename [lindex $path [expr [llength $path]-1]]

  # extract basename and check extension

  set fname [split $filename "."]

  if {[llength $fname] < 2} {
    fail "Bad filename syntax '$src'"
    return -1
  }
  if {[lindex $fname [expr [llength $fname]-1]] != "single"} {
    fail "Not .single extension '$src'"
    return -1
  }

  # setup filenames

  # $src is the name of the original testfile with absolute path
  # tests/$filename is the name of the original testfile with relative path,
  #                 relative to the testsuite directory
  set test_prg  "$filename"

  set base_name [lindex $fname 0]

  puts "Running $base_name..."

  #generate output directory

  exec mkdir -p ./single.out/out
  set outfile ./single.out/out/$base_name.out
  set refoutfile ./single.out/$base_name.out
  set errfile ./single.out/out/$base_name.err
  set referrfile ./single.out/$base_name.err

  # run the test

  set command "LD_LIBRARY_PATH=\"\${LD_LIBRARY_PATH}:../src/\" $src >$outfile 2>$errfile"
  set result ""
  set oops [catch { set result [exec sh -c $command] } catched]

  if {$oops != 0} {
    fail "test case failed for $base_name: $catched"
    return -1
  }

  # check return code from runprg

  if {$result != ""} {
    warning "Run of $base_name results in '$result'"
    return -1
  }

  if { [ file exists $refoutfile ] == 0 } {
      perror "Missing file $refoutfile" 0
  } else {
      if { [ diff $refoutfile $outfile ] != 1 } {
	  puts "Output doesn't match expected data:"
	  puts [ exec sh -c "diff -u $refoutfile $outfile || true" ]
	  fail $base_name
	  return -1
      }
  }

  if { [ file exists $referrfile ] == 0 } {
      perror "Missing file $referrfile" 0
  } else {
      if { [ diff $referrfile $errfile ] != 1 } {
	  puts "Output doesn't match expected data:"
	  puts [ exec sh -c "diff -u $referrfile $errfile || true" ]
	  fail $base_name
	  return -1
      }
  }

  # ok, all is fine

  pass $base_name

  return 0
}


#
# run a prg file for several times ( defined in subdirectory <programname> )
#
proc multi-run { src } {

  set errorOccured 0
  set path [split $src "/"]
  set root [lindex $path 0]

  # check if we're run with an absolute or an relative path
  # if relative ($src ="./xxx"), set $prefix relative
  set prefix ""
  if {$root == "."} {
	set prefix "../../"
  }

  set filename [lindex $path [expr [llength $path]-1]]

  # extract basename and check extension

  set fname [split $filename "."]

  if {[llength $fname] < 2} {
    fail "Bad filename syntax '$src'"
    return -1
  }
  if {[lindex $fname [expr [llength $fname]-1]] != "multi"} {
    fail "Not .multi extension '$src'"
    return -1
  }

  # setup filenames

  # $src is the name of the original testfile with absolute path
  # tests/$filename is the name of the original testfile with relative path,
  #                 relative to the testsuite directory
  set test_prg  "$filename"

  set base_name [lindex $fname 0]

  #							the data.<name> directory
  set basedir_name "data.$base_name"

  puts "Running $basedir_name..."

  set dirignores [list ]
  set dirignorename "$basedir_name/ignore"
  if { [ file exists $dirignorename] != 0 } {
    set fp [open $dirignorename r]
    set dirignores [read $fp]
    close $fp
  }

  #							scan through all subdirs below data.<name>
  set dircases [glob $basedir_name/*-tests $basedir_name/*-exercises ]

  foreach dircase $dircases { 
      set testPath [split $dircase "/"]
      set testFilename [lindex $testPath [expr [llength $testPath]-1]]
      set testFname [split $testFilename "."]
      set testBase_name [lindex $testFname 0]

      if {$testBase_name == "not_used"} {
	  puts "   ignoring $testBase_name"
	  continue
      }

      if { [lsearch $dirignores $testBase_name] != -1} {
	continue
      }

      if { [lsearch $dirignores "$testBase_name/"] != -1} {
	continue
      }

      # clean old results

      exec sh -c "rm -rf $dircase/*.diff $dircase/*.out $dircase/*.mistake"

      set xfails [list ]
      set xfailname "$dircase/xfail"
      if { [ file exists $xfailname] != 0 } {
	set fp [open $xfailname r]
	set xfails [read $fp]
	close $fp
      }

      set ignores [list ]
      set ignorename "$dircase/ignore"
      if { [ file exists $ignorename] != 0 } {
	set fp [open $ignorename r]
	set ignores [read $fp]
	close $fp
      }

      #							look for *-test.xml
      set testcases [glob $dircase/*-test.xml ]

      foreach testcase $testcases { 

	  set testPath [split $testcase "/"]
	  set testPathLen  [llength $testPath]
	  set testFilename [lindex $testPath [expr $testPathLen-1]]
	  set testDirname [lindex $testPath [expr $testPathLen-2]]

	  if { [lsearch $ignores $testFilename] != -1 } {
	    continue
	  }

	  set expect_to_fail 0
	  if { [lsearch $xfails $testFilename] != -1 } {
	    set expect_to_fail 1
	  }

	  set testFname [split $testFilename "."]
	  set testBase_name [lindex $testFname 0]
	  puts "   ... $testDirname/$testFilename" 

	  #generate output directory

	  set outfile "$testBase_name.out"
#	  set errfile "$testBase_name.err"
	  set errfile "/dev/null"
	  set mistakefile "$testBase_name.mistake"
	  set difffile "$testBase_name.diff"
	  set solutionfile "$testBase_name.solution"

	  # run the test

#	  set command "LD_LIBRARY_PATH=\"\${LD_LIBRARY_PATH}:../src/.libs\" $src $testcase >$outfile 2>$errfile"
	  set command "(cd $dircase; ZYPP_NOLOG=1 $prefix$src $testFilename >$outfile 2>$errfile)"

	  set result ""
	  set oops [catch { set result [exec sh -c $command] } catched]

	  if {$oops != 0} {
	      fail "test case failed for $testBase_name: $catched"
	      set errorOccured 0
	      continue
	  }

	  # check return code from runprg
      
	  if {$result != ""} {
	      warning "Run of $testBase_name results in '$result'"
	      set errorOccured 0
	      continue
	  }

	  set command "(cd $dircase; /usr/bin/fgrep \'>!>\' $outfile >$mistakefile)"
	  set oops [catch { set result [exec sh -c $command] } catched]

	  if { [ file exists $dircase/$solutionfile ] == 0 } {
	      if { $expect_to_fail == 1 } {
		xfail $testBase_name
		continue
	      }
	      perror "Testcase $testFilename has no solution" 0
	  } else {
	      set command "(cd $dircase; /usr/bin/diff -u $solutionfile $mistakefile > $difffile)"
	      set oops [catch { set result [exec sh -c $command] } catched]
	      if { $oops != "0" } {
#		  puts "Output doesn't match expected data:"
#		  puts [ exec sh -c "cat $difffile" ]
		  if { $expect_to_fail == 1 } {
		    xfail $testBase_name
		    continue
		  }
		  fail $testBase_name
		  set errorOccured 0
		  continue
	      } else {					# remove the (empty) diff
		exec sh -c "(cd $dircase; rm -f $mistakefile $difffile)"
	      }
	  }

	  # ok, all is fine
	  pass $testBase_name
      }
  }

  if { $errorOccured == 0 } {
      return 0
  } else {
      return -1
  }

}

